Metadata-Version: 2.4
Name: pytree
Version: 0.1.0
Summary: A simple and intuitive Python library for creating and manipulating tree data structures
Home-page: https://github.com/znzhao/pytree
Author: Zhenning Zhao
Author-email: Zhenning Zhao <znzhao@utexas.edu>
License: MIT
Project-URL: Homepage, https://github.com/znzhao/pytree
Project-URL: Bug Reports, https://github.com/znzhao/pytree/issues
Project-URL: Source, https://github.com/znzhao/pytree
Project-URL: Documentation, https://github.com/znzhao/pytree#readme
Keywords: tree,data-structure,node,hierarchy,graph
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Data Structures
Requires-Python: >=3.6
Description-Content-Type: text/markdown
License-File: LICENSE
Dynamic: author
Dynamic: home-page
Dynamic: license-file
Dynamic: requires-python

# PyTree

A simple and intuitive Python library for creating and manipulating tree data structures.

> **Warning**
> Some code or documentation in this project may be generated by AI. While the developer has tested the code, please review and validate all outputs before using them in production. Use at your own risk.

## Features

- **TreeNode**: Individual nodes with name, content, and parent-child relationships
- **Tree**: Complete tree structure with operations for insertion, deletion, and modification
- **JSON Serialization**: Save and load trees to/from JSON files
- **Tree Visualization**: ASCII art tree drawing functionality
- **Flexible Content**: Store any Python object as node content
- **Search Operations**: Find nodes by name or index
- **Tree Statistics**: Calculate depth and width metrics

## Installation
Install using pip:
```bash
pip install pytree
```

Or, you can install by cloning this repository:

```bash
git clone https://github.com/znzhao/pytree.git
cd pytree
pip install -e .
```

## Quick Start

### Creating a Simple Tree

```python
from pytree import TreeNode, Tree, draw_tree

# Create nodes
root = TreeNode("Company", "Acme Corp")
engineering = TreeNode("Engineering", "Tech Department")
marketing = TreeNode("Marketing", "Marketing Department")
backend = TreeNode("Backend", "Server Team")
frontend = TreeNode("Frontend", "UI Team")

# Build tree structure
root.add_child(engineering)
root.add_child(marketing)
engineering.add_child(backend)
engineering.add_child(frontend)

# Create a tree object
company_tree = Tree(root)

# Visualize the tree
draw_tree(root)
```

Output:
```
└── Company: Acme Corp
    ├── Engineering: Tech Department
    │   ├── Backend: Server Team
    │   └── Frontend: UI Team
    └── Marketing: Marketing Department
```

### Working with Tree Operations

```python
# Insert a new department
new_dept = TreeNode("HR", "Human Resources")
company_tree.insert("Company", new_dept)

# Modify existing content
company_tree.alter("Backend", "Backend Development Team")

# Get a subtree
eng_subtree = company_tree.get("Engineering")
print(eng_subtree.summary())

# Delete a node
company_tree.delete("HR")
```

### Storing Complex Data

```python
# Nodes can store any Python object
employee_data = {
    "name": "John Doe",
    "role": "Senior Developer",
    "skills": ["Python", "JavaScript", "Docker"],
    "start_date": "2023-01-15"
}

employee_node = TreeNode("john_doe", employee_data)
backend.add_child(employee_node)
```

### JSON Serialization

```python
# Save tree to JSON file
company_tree.save_json("company_structure.json")

# Load tree from JSON file
loaded_tree = Tree.load_json("company_structure.json")
```

### Tree Statistics

```python
# Get tree dimensions
print(f"Max depth: {company_tree.max_depth()}")
print(f"Max width: {company_tree.max_width()}")

# Get node summary
print(company_tree.summary())
```

## Tree Visualization with draw_tree

The `draw_tree` function provides a beautiful ASCII art representation of your tree structure using Unicode box-drawing characters. This is perfect for debugging, documentation, or simply understanding your tree's structure.

### Basic Usage

```python
from pytree import TreeNode, draw_tree

# Create a simple tree
root = TreeNode("root", "I am root")
child1 = TreeNode("child1", "First child")
child2 = TreeNode("child2", "Second child")
grandchild = TreeNode("grandchild", "I'm nested!")

root.add_child(child1)
root.add_child(child2)
child1.add_child(grandchild)

# Draw the tree
draw_tree(root)
```

Output:
```
└── root: I am root
    ├── child1: First child
    │   └── grandchild: I'm nested!
    └── child2: Second child
```

### Drawing Subtrees

You can draw any subtree by passing any node as the starting point:

```python
# Draw only the subtree starting from child1
draw_tree(child1)
```

Output:
```
└── child1: First child
    └── grandchild: I'm nested!
```

### Special Content Handling

The `draw_tree` function has special handling for dictionary content. By default, if your node's content is a dictionary containing a `'definition'` key, it will display that value instead of the entire dictionary:

```python
# Create nodes with dictionary content
root = TreeNode("concept", {"definition": "A tree data structure", "type": "data_structure"})
child = TreeNode("node", {"definition": "A single element in the tree", "properties": ["name", "content"]})

root.add_child(child)
draw_tree(root)
```

Output:
```
└── concept: A tree data structure
    └── node: A single element in the tree
```

### Custom Dictionary Key

You can specify a custom key to display from dictionary content using the `key` parameter:

```python
# Create nodes with custom dictionary keys
root = TreeNode("product", {"name": "PyTree Library", "description": "Tree data structure", "version": "1.0"})
child = TreeNode("feature", {"name": "JSON Export", "type": "functionality"})

root.add_child(child)

# Use 'name' key instead of 'definition'
draw_tree(root, key="name")
```

Output:
```
└── product: PyTree Library
    └── feature: JSON Export
```

Without a matching key, the entire dictionary would be displayed:

```python
root = TreeNode("data", {"key": "value", "number": 42})
draw_tree(root, key="description")  # Key doesn't exist
```

Output:
```
└── data: {'key': 'value', 'number': 42}
```

### Complex Tree Visualization

Here's a more complex example showing different content types:

```python
# Create a knowledge tree
knowledge = TreeNode("Programming", "Software Development")

# Programming languages
languages = TreeNode("Languages", {"definition": "Programming languages", "count": 3})
python = TreeNode("Python", {"definition": "High-level programming language", "year": 1991})
javascript = TreeNode("JavaScript", {"definition": "Web programming language", "year": 1995})
java = TreeNode("Java", {"definition": "Object-oriented programming language", "year": 1995})

# Concepts
concepts = TreeNode("Concepts", "Core programming concepts")
oop = TreeNode("OOP", {"definition": "Object-Oriented Programming", "paradigm": "object-oriented"})
functional = TreeNode("Functional", {"definition": "Functional Programming", "paradigm": "functional"})

# Build the tree
knowledge.add_child(languages)
knowledge.add_child(concepts)
languages.add_child(python)
languages.add_child(javascript)
languages.add_child(java)
concepts.add_child(oop)
concepts.add_child(functional)

# Visualize
draw_tree(knowledge)
```

Output:
```
└── Programming: Software Development
    ├── Languages: Programming languages
    │   ├── Python: High-level programming language
    │   ├── JavaScript: Web programming language
    │   └── Java: Object-oriented programming language
    └── Concepts: Core programming concepts
        ├── OOP: Object-Oriented Programming
        └── Functional: Functional Programming
```

### Using with Tree Objects

You can also use `draw_tree` with `Tree` objects by accessing their root:

```python
tree = Tree(root)
draw_tree(tree.root)

# Or use the convenient .draw() method
tree.draw()

# With custom key
tree.draw(key="name")
```

### Convenient .draw() Methods

Both `TreeNode` and `Tree` objects have a convenient `.draw()` method:

```python
# Draw from any TreeNode
node.draw()
node.draw(key="custom_key")

# Draw entire Tree
tree.draw()
tree.draw(key="custom_key")
```

### Tips for Better Visualization

1. **Keep node names concise**: Long names can make the tree hard to read
2. **Use meaningful content**: The content appears after the colon, so make it descriptive
3. **Use the 'definition' key**: For dictionary content, use a 'definition' key for cleaner output
4. **Consider tree depth**: Very deep trees might be hard to read in console output

### Unicode Characters Used

The `draw_tree` function uses these Unicode box-drawing characters:
- `└──` (U+2514 U+2500 U+2500): For the last child at each level
- `├──` (U+251C U+2500 U+2500): For intermediate children
- `│   ` (U+2502): For vertical continuation lines
- `    ` (4 spaces): For padding after the last child

## API Reference

### TreeNode

#### Constructor
- `TreeNode(name: str, content: Any = None)`: Create a new tree node

#### Methods
- `add_child(child: TreeNode)`: Add a child node
- `remove_child(child: Union[TreeNode, str, int])`: Remove a child by node, name, or index
- `get_child(key: Union[str, int])`: Get child by name or index
- `set_content(content: Any)`: Update node content
- `get_subtree(name: str)`: Find and return subtree by node name
- `to_dict()`: Convert node and its subtree to dictionary
- `from_dict(data: Dict)`: Create node from dictionary (static method)
- `max_depth()`: Calculate maximum depth from this node
- `max_width()`: Calculate maximum width from this node
- `summary()`: Get a formatted summary of the node
- `draw(key: str = "definition")`: Print ASCII art representation of the node and its subtree

### Tree

#### Constructor
- `Tree(root: TreeNode)`: Create a tree with the given root node

#### Methods
- `insert(parent_name: str, node: TreeNode)`: Insert node under specified parent
- `delete(node_name: str)`: Delete node by name
- `alter(node_name: str, new_content: Any)`: Change content of specified node
- `get(key: Union[str, int])`: Get subtree by name or index
- `save_json(filepath: str)`: Save tree to JSON file
- `load_json(filepath: str)`: Load tree from JSON file (static method)
- `max_depth()`: Get maximum depth of entire tree  
- `max_width()`: Get maximum width of entire tree
- `summary()`: Get formatted summary of the tree
- `draw(key: str = "definition")`: Print ASCII art representation of the entire tree

### Utility Functions

#### draw_tree
- `draw_tree(node: TreeNode, prefix: str = "", is_last: bool = True, key: str = "definition")`: Print ASCII art representation of tree

**Parameters:**
- `node` (TreeNode): The root node of the tree/subtree to visualize
- `prefix` (str, optional): Internal parameter for indentation. Leave as default.
- `is_last` (bool, optional): Internal parameter for formatting. Leave as default.
- `key` (str, optional): Dictionary key to display for dict content. Defaults to "definition".

**Special Features:**
- Uses Unicode box-drawing characters for clean tree visualization
- Customizable handling for dictionary content with specified key
- Recursively displays entire subtree structure
- Works with any TreeNode as starting point

**Usage Examples:**
```python
# Basic usage - draw entire tree
draw_tree(root_node)

# Draw subtree starting from any node
draw_tree(some_child_node)

# Use custom dictionary key
draw_tree(root_node, key="name")

# The function automatically handles the formatting
```

## Examples

The PyTree package includes ready-to-run example files that demonstrate all the key features:

### Running the Examples

**Quick Examples** - Fast overview of main features:
```bash
python -m pytree.quick_examples
```

**Comprehensive Examples** - Detailed demonstrations:
```bash
python -m pytree.examples
```

These example files show practical usage patterns and can serve as templates for your own projects.

### File System Tree

```python
from pytree import TreeNode, Tree, draw_tree

# Create a file system structure
root = TreeNode("/", "root directory")
home = TreeNode("home", "user directories")
usr = TreeNode("usr", "system programs")
user = TreeNode("alice", "alice's home")
documents = TreeNode("Documents", "document folder")
projects = TreeNode("Projects", "coding projects")

# Add some files
readme = TreeNode("README.md", "Project documentation")
code = TreeNode("main.py", "Main application file")

# Build structure
root.add_child(home)
root.add_child(usr)
home.add_child(user)
user.add_child(documents)
user.add_child(projects)
projects.add_child(readme)
projects.add_child(code)

fs_tree = Tree(root)

# Draw the entire file system
print("Complete file system:")
draw_tree(root)

# Draw just the user's directory
print("\nUser's directory only:")
draw_tree(user)
```

Output:
```
Complete file system:
└── /: root directory
    ├── home: user directories
    │   └── alice: alice's home
    │       ├── Documents: document folder
    │       └── Projects: coding projects
    │           ├── README.md: Project documentation
    │           └── main.py: Main application file
    └── usr: system programs

User's directory only:
└── alice: alice's home
    ├── Documents: document folder
    └── Projects: coding projects
        ├── README.md: Project documentation
        └── main.py: Main application file
```

### Decision Tree

```python
# Create a simple decision tree
decision_root = TreeNode("Weather", "Is it sunny?")
sunny = TreeNode("Sunny", "Go to beach")
rainy = TreeNode("Rainy", "Stay inside")
cloudy = TreeNode("Cloudy", "Go for a walk")

decision_root.add_child(sunny)
decision_root.add_child(rainy)  
decision_root.add_child(cloudy)

decision_tree = Tree(decision_root)

# Save decision tree
decision_tree.save_json("weather_decisions.json")
```

### Organizational Chart

```python
# Company hierarchy with definition-based content for clean visualization
ceo = TreeNode("CEO", {"definition": "Jane Smith - Chief Executive Officer", "level": "Executive"})
cto = TreeNode("CTO", {"definition": "Bob Johnson - Chief Technology Officer", "level": "C-Level"})
cfo = TreeNode("CFO", {"definition": "Alice Brown - Chief Financial Officer", "level": "C-Level"})

dev_manager = TreeNode("Dev Manager", {"definition": "Charlie Wilson - Development Manager", "level": "Manager"})
senior_dev = TreeNode("Senior Dev", {"definition": "Diana Davis - Senior Developer", "level": "Senior"})
intern = TreeNode("Intern", {"definition": "Alex Johnson - Software Engineering Intern", "level": "Entry"})

# Build hierarchy
ceo.add_child(cto)
ceo.add_child(cfo)
cto.add_child(dev_manager)
dev_manager.add_child(senior_dev)
dev_manager.add_child(intern)

org_chart = Tree(ceo)

# Display the organization structure
print("Company Organization Chart:")
draw_tree(ceo)

print(f"\nOrganization depth: {org_chart.max_depth()} levels")
print(f"Maximum width: {org_chart.max_width()} people at one level")

# Show just the tech department
print("\nTechnology Department:")
draw_tree(cto)
```

Output:
```
Company Organization Chart:
└── CEO: Jane Smith - Chief Executive Officer
    ├── CTO: Bob Johnson - Chief Technology Officer
    │   └── Dev Manager: Charlie Wilson - Development Manager
    │       ├── Senior Dev: Diana Davis - Senior Developer
    │       └── Intern: Alex Johnson - Software Engineering Intern
    └── CFO: Alice Brown - Chief Financial Officer

Organization depth: 4 levels
Maximum width: 2 people at one level

Technology Department:
└── CTO: Bob Johnson - Chief Technology Officer
    └── Dev Manager: Charlie Wilson - Development Manager
        ├── Senior Dev: Diana Davis - Senior Developer
        └── Intern: Alex Johnson - Software Engineering Intern
```

## Testing

Run the test suite:

```bash
python -m pytest test_pytree.py -v
```

Or with unittest:

```bash
python -m unittest test_pytree.py -v
```

## Requirements

- Python 3.6+
- No external dependencies for core functionality

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Changelog

### Version 0.1.0
- Initial release
- Basic tree node and tree operations
- JSON serialization support
- Tree visualization

- Comprehensive test suite
